package main

import (
	"crypto/sha1"
	"crypto/sha256"
	"fmt"
	"os"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// ---------- 모델 ----------
type SimpleItem struct {
	Value string `json:"value"`
}

// ---------- 체인코드 ----------
type ItemContract struct {
	contractapi.Contract
}

// ★ util: 패턴별 Key 생성
func generateKey(pattern string, idx int) string {
	switch pattern {
	case "sequ":
		// return fmt.Sprintf("sequ-%016d", idx)
		return fmt.Sprintf("%032d", idx)
	case "rand":
		// return fmt.Sprintf("rand-%05d", uuid.NewString())
		// h := sha1.Sum([]byte(fmt.Sprintf("%s-%d", pattern, idx)))
		h := sha256.New().Sum([]byte(fmt.Sprintf("%s-%d", pattern, idx)))
		// h := sha256.Sum([]byte(fmt.Sprintf("%s-%d", pattern, idx)))
		// return fmt.Sprintf("rand-%x", h[:8]) // ⇒ idx → 고정값
		return fmt.Sprintf("%x", h[:16]) // ⇒ idx → 고정값
	case "hash":
		h := sha1.Sum([]byte(fmt.Sprint(idx)))
		// return fmt.Sprintf("hash-%x", h[:8])
		return fmt.Sprintf("%x", h[:8])
	case "shortprefix":
		prefix := fmt.Sprintf("%024d", idx)
		h := sha256.New().Sum([]byte(fmt.Sprintf("%s%d", pattern, idx)))
		return fmt.Sprintf("%s%x", prefix, h[:8])
	default:
		return fmt.Sprintf("unknown-%d", idx)
	}
}

// PutItem(key,value) : 단건 삽입
func (c *ItemContract) PutItem(ctx contractapi.TransactionContextInterface,
	key, value string) error {

	return ctx.GetStub().PutState(key, []byte(value))
}

func writeToFile(filepath string, content string) error {

	file, err := os.OpenFile(filepath, os.O_RDWR|os.O_CREATE, 0777)
	if err != nil {
		// panic(err)
		return fmt.Errorf("failed to open file: %v", err)
	}
	defer file.Close()

	absPath, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	head := fmt.Sprintf("file: %s%s\n", absPath, file.Name())
	_, err = file.WriteString(head)
	if err != nil {
		// panic(err)
		return fmt.Errorf("failed to write to file: %v", err)
	}

	_, err = file.WriteString(content)
	if err != nil {
		// panic(err)
		return fmt.Errorf("failed to write to file: %v", err)
	}

	fmt.Printf("Data written to file successfully. filepath: %s/%s\n", absPath, file.Name())

	return nil
}

// InitBulk(offset, count, pattern) : 테스트용 일괄 삽입
func (c *ItemContract) InitBulk(ctx contractapi.TransactionContextInterface, offset int, count int, pattern string) error {

	var insertedKeys []string
	// return fmt.Errorf("offset: %d, count: %d, pattern: %s\n", offset, count, pattern)
	for i := 0; i < count; i++ {
		k := generateKey(pattern, offset+i)
		// v := &SimpleItem{Value: fmt.Sprintf("val-%d", i)} // 이전 코드
		// bytes, marshalErr := json.Marshal(v) // 이전 코드

		stringValue := fmt.Sprintf("val-%d", i) // 문자열 값 생성
		s := fmt.Sprintf("key: %s, value: %s\n", k, stringValue)
		writeToFile("InitBulk.txt", s)
		bytes := []byte(stringValue) // 문자열을 바이트 슬라이스로 변환

		// if marshalErr != nil { // JSON 마샬링 에러 확인은 더 이상 필요 없음
		// 	return fmt.Errorf("failed to marshal SimpleItem for key %s: %v", k, marshalErr)
		// }
		// if bytes == nil && marshalErr == nil { // 바이트 슬라이스가 nil인지 확인은 여전히 유효할 수 있으나, []byte(string)은 일반적으로 nil을 반환하지 않음
		// 	return fmt.Errorf("marshaled data is nil for key %s without a marshal error", k)
		// }
		if bytes == nil { //바이트 슬라이스가 nil인지 확인
			return fmt.Errorf("generated byte slice is nil for key %s", k)
		}

		// 데이터 저장
		if err := ctx.GetStub().PutState(k, bytes); err != nil {
			return fmt.Errorf("PutState failed for key %s: %v", k, err)
		}

		insertedKeys = append(insertedKeys, k)

		// // 저장 확인 (같은 트랜잭션 내에서)
		// checkBytes, err := ctx.GetStub().GetState(k)
		// if err != nil { // GetState 자체에서 에러가 발생한 경우
		// 	return fmt.Errorf("GetState failed for key '%s' after PutState: %v", k, err)
		// }
		// if checkBytes == nil { // GetState는 성공했으나 값이 nil인 경우 (PutState에 nil 바이트가 전달되었을 가능성)
		// 	return fmt.Errorf("key '%s' does not exist or value is nil after PutState (bytes length sent to PutState: %d): %v", k, len(bytes), err)
		// }

	}
	fmt.Printf("all %d keys are saved\n", len(insertedKeys))
	return nil
}

// GetAllKeys : 생성된 모든 키 값들을 반환하고, 모든 키-값 쌍을 호스트에 출력
func (c *ItemContract) GetAllKeys(ctx contractapi.TransactionContextInterface) ([]string, error) {
	max_count := 10000

	// 모든 상태 범위 조회
	iterator, err := ctx.GetStub().GetStateByRange("", "")
	if err != nil {
		return nil, fmt.Errorf("GetState Error: %v", err)
	}
	defer iterator.Close()

	var logs []string
	s := fmt.Sprintln("--- All Key-Value Pairs in Ledger ---")
	fmt.Print(s)
	logs = append(logs, s)

	count := 0
	for iterator.HasNext() {
		if count >= max_count {
			break
		}
		count++
		response, err := iterator.Next()
		if err != nil {
			return nil, fmt.Errorf("Iterator error: %v", err)
		}

		// 모든 키-값 쌍을 호스트에 출력
		// response.Value는 []byte 타입이므로 문자열로 변환하여 출력합니다.
		s := fmt.Sprintf("Key: %s, Value: %s\n", response.Key, string(response.Value))
		fmt.Print(s)
		logs = append(logs, s)
		// fmt.Printf("Key: %s, Value: %s\n", response.Key, string(response.Value))

		// 패턴으로 시작하는 키만 필터링하여 반환 목록에 추가

		// logs = append(logs, response.Key)

	}
	s = fmt.Sprintln("--- End of Key-Value Pairs ---")
	fmt.Print(s)
	logs = append(logs, s)

	return logs, nil
}

func main() {
	cc, err := contractapi.NewChaincode(new(ItemContract))
	if err != nil {
		panic(err)
	}
	if err := cc.Start(); err != nil {
		panic(err)
	}
}
